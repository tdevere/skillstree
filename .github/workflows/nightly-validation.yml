name: Nightly Validation
on:
  schedule:
    # Run every 30 minutes between 22:00 - 23:59 UTC
    - cron: '*/30 22-23 * * *'
    # Run every 30 minutes between 00:00 - 05:59 UTC
    - cron: '*/30 0-5 * * *'
    # Final summary run at 06:00 UTC
    - cron: '0 6 * * *'
  workflow_dispatch:

concurrency:
  group: nightly-rotation
  cancel-in-progress: true

permissions:
  contents: write
  issues: write

jobs:
  nightly:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (persist credentials)
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install deps
        run: python -m pip install --upgrade pip && pip install -r requirements.txt

      - name: Run validation script and write JSON
        run: |
          python run_validation.py --nodes-file nightly_nodes.txt --output nightly_result.json || true

      - name: Create issues for failing checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = 'nightly_result.json';
            if (!fs.existsSync(path)) { console.log('no result file'); return; }
            const res = JSON.parse(fs.readFileSync(path, 'utf8'));
            const failures = res.failures || [];
            for (const r of failures) {
              const title = `Validation failed: ${r.node} rank ${r.rank} - ${r.check}`;
              const body = `Automated nightly validation failed.\n\n**Node**: ${r.node}\n**Rank**: ${r.rank}\n**Command**: ${r.command}\n**Exit**: ${r.exit_code}\n\nOutput:\n\`\`\`\n${r.output}\n\`\`\`\n\nPlease investigate or mark as manual_check.`;
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['automated-failure','needs-triage']
              });
            }

      - name: Create next improvement task and rotate tasks file
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const repo = context.repo;
            const tasksPath = 'tasks/next-tasks.md';
            if (!fs.existsSync(tasksPath)) { console.log('no tasks file'); return; }
            const tasksRaw = fs.readFileSync(tasksPath,'utf8');
            const lines = tasksRaw
              .split('\n')
              .map(l => l.trim())
              .filter(l => l && !l.startsWith('#'));
            if (!lines.length) { console.log('no tasks present'); return; }
            const task = lines[0];
            const title = `Nightly task: ${task.slice(0,100)}`;
            // avoid duplicate issues
            const { data: issues } = await github.rest.issues.listForRepo({ owner: repo.owner, repo: repo.repo, state: 'open' });
            if (issues.some(i => i.title === title)) { console.log('task issue already exists, skipping rotation'); return; }
            await github.rest.issues.create({ owner: repo.owner, repo: repo.repo, title, body: task, labels: ['daily-task'] });

            // Rotate: remove the first task and update file via API with retry
            const maxAttempts = 3;
            let attempt = 0;
            while (attempt < maxAttempts) {
              attempt++;
              try {
                const file = await github.rest.repos.getContent({ owner: repo.owner, repo: repo.repo, path: tasksPath });
                const sha = file.data.sha;
                const remaining = tasksRaw.split('\n').slice(1).join('\n').trim() + '\n';
                await github.rest.repos.createOrUpdateFileContents({ owner: repo.owner, repo: repo.repo, path: tasksPath, message: 'chore: rotate nightly task', content: Buffer.from(remaining,'utf8').toString('base64'), sha });
                console.log('rotated tasks file');
                break;
              } catch (err) {
                console.log('rotation attempt', attempt, 'failed:', err.message);
                if (attempt >= maxAttempts) throw err;
                await new Promise(res => setTimeout(res, 1000 * attempt));
              }
            }
