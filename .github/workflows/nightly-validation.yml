name: Nightly Validation
on:
  schedule:
    # Run every 30 minutes between 22:00 - 23:59 UTC
    - cron: '*/30 22-23 * * *'
    # Run every 30 minutes between 00:00 - 05:59 UTC
    - cron: '*/30 0-5 * * *'
    # Final summary run at 06:00 UTC
    - cron: '0 6 * * *'
  workflow_dispatch:

concurrency:
  group: nightly-rotation
  cancel-in-progress: true

permissions:
  contents: write
  issues: write

jobs:
  nightly:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (persist credentials)
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: PAT diagnostics and test
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.NIGHTLY_TOKEN }}
          script: |
            const fs = require('fs');
            const repo = context.repo;
            const result = { timestamp: new Date().toISOString(), user: null, repo: null, tasksFile: null, issueCreate: null, errors: [] };
            try {
              const u = await github.rest.users.getAuthenticated();
              result.user = { login: u.data.login, id: u.data.id };
            } catch (err) {
              result.errors.push({ step: 'getAuthenticated', message: err.message });
            }
            try {
              const r = await github.rest.repos.get({ owner: repo.owner, repo: repo.repo });
              result.repo = { full_name: r.data.full_name, private: r.data.private };
            } catch (err) {
              result.errors.push({ step: 'getRepo', message: err.message });
            }
            try {
              const c = await github.rest.repos.getContent({ owner: repo.owner, repo: repo.repo, path: 'tasks/next-tasks.md' });
              result.tasksFile = { exists: true, sha: c.data.sha, size: c.data.size };
            } catch (err) {
              result.tasksFile = { exists: false, error: err.message };
            }
            try {
              const title = `pat-diagnostic: automated test ${new Date().toISOString()}`;
              const issue = await github.rest.issues.create({ owner: repo.owner, repo: repo.repo, title, body: 'Automated PAT diagnostic; will be closed immediately.' });
              result.issueCreate = { created: true, number: issue.data.number };
              await github.rest.issues.update({ owner: repo.owner, repo: repo.repo, issue_number: issue.data.number, state: 'closed' });
              result.issueCreate.closed = true;
            } catch (err) {
              result.issueCreate = { created: false, error: err.message };
              result.errors.push({ step: 'createOrCloseIssue', message: err.message });
            }
            fs.writeFileSync('pat_diagnostic.json', JSON.stringify(result, null, 2));
            console.log('WROTE pat_diagnostic.json');

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Upload PAT diagnostic artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pat_diagnostic
          path: pat_diagnostic.json

      - name: Install deps
        run: python -m pip install --upgrade pip && pip install -r requirements.txt

      - name: Run validation script and write JSON
        run: |
          python run_validation.py --nodes-file nightly_nodes.txt --output nightly_result.json || true

      - name: Create issues for failing checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.NIGHTLY_TOKEN }}
          script: |
            const fs = require('fs');
            const path = 'nightly_result.json';
            if (!fs.existsSync(path)) { console.log('no result file'); return; }
            const res = JSON.parse(fs.readFileSync(path, 'utf8'));
            const failures = res.failures || [];
            for (const r of failures) {
              const title = `Validation failed: ${r.node} rank ${r.rank} - ${r.check}`;
              const body = `Automated nightly validation failed.\n\n**Node**: ${r.node}\n**Rank**: ${r.rank}\n**Command**: ${r.command}\n**Exit**: ${r.exit_code}\n\nOutput:\n\`\`\`\n${r.output}\n\`\`\`\n\nPlease investigate or mark as manual_check.`;
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['automated-failure','needs-triage']
              });
            }

      - name: Create next improvement task and rotate tasks file
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.NIGHTLY_TOKEN }}
          script: |
            const fs = require('fs');
            const repo = context.repo;
            const tasksPath = 'tasks/next-tasks.md';
            if (!fs.existsSync(tasksPath)) { console.log('no tasks file'); return; }
            const tasksRaw = fs.readFileSync(tasksPath,'utf8');
            const lines = tasksRaw
              .split('\n')
              .map(l => l.trim())
              .filter(l => l && !l.startsWith('#'));
            if (!lines.length) { console.log('no tasks present'); return; }
            const task = lines[0];
            const titleBase = `Nightly task: ${task.slice(0,100)}`;

            // Find existing open issues that match the title base (exact or startsWith)
            const { data: issues } = await github.rest.issues.listForRepo({ owner: repo.owner, repo: repo.repo, state: 'open' });
            const candidates = issues.filter(i => i.title && (i.title === titleBase || i.title.startsWith(titleBase)));

            // Only skip rotation if an existing candidate is marked in-progress.
            const hasInProgress = candidates.some(i => (i.labels || []).some(l => (l.name || l).toString().toLowerCase() === 'in-progress'));
            if (hasInProgress) { console.log('found in-progress task issue, skipping rotation'); return; }

            // Append a short timestamp to title to guarantee uniqueness and preserve titleBase for matching
            const ts = new Date().toISOString().replace(/[:.]/g, '-');
            const title = `${titleBase} (${ts})`;

            // Create the issue and rotate the file
            await github.rest.issues.create({ owner: repo.owner, repo: repo.repo, title, body: task, labels: ['daily-task'] });

            // Rotate: remove the first task and update file via API with retry
            const maxAttempts = 3;
            let attempt = 0;
            while (attempt < maxAttempts) {
              attempt++;
              try {
                const file = await github.rest.repos.getContent({ owner: repo.owner, repo: repo.repo, path: tasksPath });
                const sha = file.data.sha;
                const remaining = tasksRaw.split('\n').slice(1).join('\n').trim() + '\n';
                await github.rest.repos.createOrUpdateFileContents({ owner: repo.owner, repo: repo.repo, path: tasksPath, message: 'chore: rotate nightly task', content: Buffer.from(remaining,'utf8').toString('base64'), sha });
                console.log('rotated tasks file');
                break;
              } catch (err) {
                console.log('rotation attempt', attempt, 'failed:', err.message);
                if (attempt >= maxAttempts) throw err;
                await new Promise(res => setTimeout(res, 1000 * attempt));
              }
            }
